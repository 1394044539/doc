## 一、Shell脚本

### 1、选择解释器

在shell脚本中，#表示注释，而#! 表示引用，用来定义使用哪种sh解释器来解释脚本，一般文件第一行都需要输入下面的内容。

```sh
#!bin/bash
```

**这里解释一下#!bin/bash和#!/bin/sh的区别：**

#!/bin/sh就相当于#!/bin/bash--posix，posix相当于一种规范，具体可以百度

### 2、数据类型

shell脚本中只有三种数据类型：

- 字符串：<a href='#shell-string'>详解</a>
- 整型：<a href='#shell-integer'>详解</a>
- 数组：<a href='#shell-array'>详解</a>

### 3、变量

**定义变量：**

常规的定义变量的三种方式

```sh
variable=value
variable='value'
variable="value"
```

解释：

- 因为shell脚本的特殊性，用常规方法定义的变量都是**字符串**，整型和数组在后面会有解释

- variable 是变量名，value 是赋给变量的值

- 如果value中间含有空格，则必须用引号包裹住

- “＝”号左右**不能有空格**，shell对空格这一块比其他语言严格，需要注意

- 变量名必须以字母或者下划线开头，由数字、字母、下划线组成，不能使用 Shell 里的关键字

- 单引号和双引号的区别：单引号里面的内容全部看做写死的字符串，而双引号会解析内部的变量

  ```sh
  name="zhangsan"
  value1='姓名：${name}'
  value2="姓名：${name}"
  echo $value1 # 结果为：姓名：${name}
  echo $value2 # 结果为：姓名：zhangsan
  ```

**使用变量：**

常规使用变量的两种方法

```sh
echo $author
echo ${author}
```

解释：

- {}可以加可以不加，主要是为了区分边界，建议**全加上**，不加的点外卖没有餐具
- 字符串拼接变量在字符串那边详解

**修改变量：**

直接修改即可，赋值时不需要$

```sh
url="123"
echo ${url}
url="456"
echo ${url}
```

### 4、<span id='replace'>替换</span>

将某条语句执行结果放到某个变量中，有两种方式可以完成命令替换，一种是反引号`` ``，一种是$()

```sh
variable=`commands`
variable=$(commands)
```

解释：

- 建议都用$()，不用的斗地主3456没有7
- 经典用法比如说time=$(date)，result=$(curl url)，都需要用替换来进行，直接time=date，会被当做赋值

### 5、特殊变量

shell脚本有几种传参的方式，下面慢慢讲

| 变量      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| $0        | 当前脚本的文件名。                                           |
| $n（n≥1） | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。 |
| $#        | 传递给脚本或函数的参数个数。                                 |
| $*        | 传递给脚本或函数的所有参数。                                 |
| $@        | 传递给脚本或函数的所有参数。当被双引号`" "`包含时，$@ 与 $* 稍有不同 |
| $?        | 上个命令的退出状态，或函数的返回值                           |
| $$        | 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 |

- $0：文件名

  ```sh
  #假设文件名交test.sh，它就输出test.sh
  echo ${0}
  ```

- $n：参数位置

  按照位置进行传参

  ```sh
  echo ${1}
  echo ${2}
  ```

  假设文件名是test.sh，输入命令

  ```shell
  sh test.sh 123 456
  123
  456
  ```

  注意的点：

  - 执行shell脚本时，参数之间用空格区分
  - 如果参数带有空格，请用""进行包裹
  - 对于参数中间有引号的，如json数据这种，用''拼接，但是不建议传这种复杂参数，很烦。。。
  - 不能自定义参数名字，通过key->value的方法进行传值

- $#：参数个数

- $*：所有参数

  在使用$*时，如果加上了""，会把所有参数当做一个字符串，简而言之不能循环

- $@：所有参数

  在使用$@时，如果加上了""，会把每一个参数都当做一个单独的字符串，可以通过循环的方式遍历，相当于自己是一个数组

- $?

  有两种用法：

  - 获取命令的退出状态

    在执行任意一个命令后，都可以使用$?获取上一条命令的退出状态，如下

    ```shell
    [mozhiyan@localhost demo]$ bash ./test.sh 100  
    [mozhiyan@localhost demo]$ echo $?
    0
    ```

  - 获取函数的返回值

    ```sh
    #!/bin/bash
    #得到两个数相加的和
    function add(){
        return `expr $1 + $2`
    }
    add 23 50  #调用函数
    echo $?  #获取函数返回值
    ```

- $$：获取当前脚本的进程id

### 6、<span id='shell-string'>字符串</span>

在变量中写过，常规的三种赋值方法，三种的区别也在变量中讲过，所以这里直接讲一下字符串的使用规则和一些方法

```sh
variable=value
variable='value'
variable="value"
```

**字符串拼接：**

因为字符串的定义方式和引用方式有些随意，拼接起来特别容易出现各种各样的问题，需要注意一下

```sh
#!/bin/bash
name="Shell"
url="http://c.biancheng.net/shell/"
str1=$name$url  #中间不能有空格
str2="$name $url"  #如果被双引号包围，那么中间可以有空格
str3=$name": "$url  #中间可以出现别的字符串
str4="$name: $url"  #这样写也可以
str5="${name}Script: ${url}index.html"  #这个时候需要给变量名加上大括号
```

关于引号嵌套的问题：

需要灵活运用单引号进行定义，假设数据为一串json数据

```sh
json='{
	"name":"zhangsan",
	"age":"23",
}'
echo "${json}"
```

类似的情况就需要灵活运用单引号，双引号和{}

**字符串长度：**

在变量前面加上#号，然后用{}包裹起来

```sh
${#string_name}
```

**字符串截取：**

一共有8中方法，主要对后面四个稍微进行举例讲解

| 格式                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ${string: start :length}   | 从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。 |
| ${string: start}           | 从 string 字符串的左边第 start 个字符开始截取，直到最后。    |
| ${string: 0-start :length} | 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。 |
| ${string: 0-start}         | 从 string 字符串的右边第 start 个字符开始截取，直到最后。    |
| ${string#*chars}           | 从 string 字符串第一次出现 chars 的位置开始，截取 chars 右边的所有字符。 |
| ${string##*chars}          | 从 string 字符串最后一次出现 chars 的位置开始，截取 chars 右边的所有字符。 |
| ${string%chars*}           | 从 string 字符串第一次出现 chars 的位置开始，截取 chars 左边的所有字符。 |
| ${string%%chars*}          | 从 string 字符串最后一次出现 chars 的位置开始，截取 chars 左边的所有字符。 |

- 对于chars，都不包括自身
- *是通配符的一种，表示任意长度的字符串

### 7、<span id='shell-integer'>整型</span>

因为shell脚本默认定义字符串，所以定义整型需要用declare -i

```sh
declare -i num=3
```

- 其实很多时候不需要这样进行赋值，强行定义成整型主要是对数字运算更为方便，但其实我们很多时候用特点的方法进行运算，这个放到后面去说明
- 整型变量不允许被赋值为字符串，如果整型数被赋值为字符或不带空格的字符串时，系统不会报错，并且整型变量实际被赋值为0
- 整型数被赋值为带空格的字符串时，系统将报错

### 8、<span id='shell-array'>数组</span>

**定义：**

常规定义数组的方法，把数组用（）包裹起来，用空格进行分割

```sh
array_name=(ele1 ele2 ele3 elen)
```

shell中的数组是弱类型，可以随意放字符串和整型，但是只支持一维数组

```sh
arr=(20 56 "123")
```

shell中的数组定义方式比较随意，长度也不做限制，可以在任意index下加入数据，如下数组的长度只有3，且只有该下标下才有，ages[0]下实际是空的

```sh
ages=([3]=24 [5]=19 [10]=12)
```

**使用：**

和大部分语言一样，用arr[index]即可

```sh
${array_name[index]}
```

两种特殊的取出方法，可以获取全部的数据，*取出来的值被当做一整个字符串，而@取出来的值可以循环

```sh
${nums[*]}
${nums[@]}
```

**数组的长度：**

需要用到上面的两种取值方法，并且在参数名前面加上#，这里是针对数组的特殊用法，和取字符串长度很像${#string_name}

```sh
${#array_name[@]}
${#array_name[*]}
```

**数组拼接：**

直接往里面拼就行，可以直接写变量，可以直接写值，注意中间的空格不能少

```sh
array_new=(${array1[*]}  ${array2[*]})
array_new=(${array_new[*]}  1)
```

**删除数组：**

unset 关键字

```sh
unset array_name[index] #删除下标中的元素
unset array_name #删除整个数组
```

### 9、关联数组

关联数组和普通数组的各种方法都是一样的，唯一的区别是，他类似一个map，下标为自定的字符串，通过key->value组合的数据结构

```sh
#定义declare -A来定义
declare -A color=(["red"]="#ff0000", ["green"]="#00ff00", ["blue"]="#0000ff")
```

### 10、内建命令（重要）

内建命令就是Linux本身的命令，而不是由外部文件执行的命令，**内建命令可以在shell脚本中直接编写**，并且是关键字不允许被当做变量名定义

比如cd是切换目录，ipconfig是查看ip，但是前者是内建命令，后者则是一个可执行文件，可以用**type**命令来判断是否为内建命令

```shell
[root@localhost ~]# type cd
cd is a Shell builtin
[root@localhost ~]# type ifconfig
ifconfig is /sbin/ifconfig
```

列出大部分的内建命令

| 命令      | 说明                                                  |
| --------- | ----------------------------------------------------- |
| :         | 扩展参数列表，执行重定向操作                          |
| .         | 读取并执行指定文件中的命令（在当前 shell 环境中）     |
| alias     | 为指定命令定义一个别名，比如alias ll='ls -l           |
| bg        | 将作业以后台模式运行                                  |
| bind      | 将键盘序列绑定到一个 readline 函数或宏                |
| break     | 退出 for、while、select 或 until 循环                 |
| builtin   | 执行指定的 shell 内建命令                             |
| caller    | 返回活动子函数调用的上下文                            |
| cd        | 将当前目录切换为指定的目录                            |
| command   | 执行指定的命令，无需进行通常的 shell 查找             |
| compgen   | 为指定单词生成可能的补全匹配                          |
| complete  | 显示指定的单词是如何补全的                            |
| compopt   | 修改指定单词的补全选项                                |
| continue  | 继续执行 for、while、select 或 until 循环的下一次迭代 |
| declare   | 声明一个变量或变量类型。                              |
| dirs      | 显示当前存储目录的列表                                |
| disown    | 从进程作业表中刪除指定的作业                          |
| echo      | 将指定字符串输出到 STDOUT                             |
| enable    | 启用或禁用指定的内建shell命令                         |
| eval      | 将指定的参数拼接成一个命令，然后执行该命令            |
| exec      | 用指定命令替换 shell 进程                             |
| exit      | 强制 shell 以指定的退出状态码退出                     |
| export    | 设置子 shell 进程可用的变量                           |
| fc        | 从历史记录中选择命令列表                              |
| fg        | 将作业以前台模式运行                                  |
| getopts   | 分析指定的位置参数                                    |
| hash      | 查找并记住指定命令的全路径名                          |
| help      | 显示帮助文件                                          |
| history   | 显示命令历史记录                                      |
| jobs      | 列出活动作业                                          |
| kill      | 向指定的进程 ID(PID) 发送一个系统信号                 |
| let       | 计算一个数学表达式中的每个参数                        |
| local     | 在函数中创建一个作用域受限的变量                      |
| logout    | 退出登录 shell                                        |
| mapfile   | 从 STDIN 读取数据行，并将其加入索引数组               |
| popd      | 从目录栈中删除记录                                    |
| printf    | 使用格式化字符串显示文本                              |
| pushd     | 向目录栈添加一个目录                                  |
| pwd       | 显示当前工作目录的路径名                              |
| read      | 从 STDIN 读取一行数据并将其赋给一个变量               |
| readarray | 从 STDIN 读取数据行并将其放入索引数组                 |
| readonly  | 从 STDIN 读取一行数据并将其赋给一个不可修改的变量     |
| return    | 强制函数以某个值退出，这个值可以被调用脚本提取        |
| set       | 设置并显示环境变量的值和 shell 属性                   |
| shift     | 将位置参数依次向下降一个位置                          |
| shopt     | 打开/关闭控制 shell 可选行为的变量值                  |
| source    | 读取并执行指定文件中的命令（在当前 shell 环境中）     |
| suspend   | 暂停 Shell 的执行，直到收到一个 SIGCONT 信号          |
| test      | 基于指定条件返回退出状态码 0 或 1                     |
| times     | 显示累计的用户和系统时间                              |
| trap      | 如果收到了指定的系统信号，执行指定的命令              |
| type      | 显示指定的单词如果作为命令将会如何被解释              |
| typeset   | 声明一个变量或变量类型。                              |
| ulimit    | 为系统用户设置指定的资源的上限                        |
| umask     | 为新建的文件和目录设置默认权限                        |
| unalias   | 刪除指定的别名                                        |
| unset     | 刪除指定的环境变量或 shell 属性                       |
| wait      | 等待指定的进程完成，并返回退出状态码                  |

#### 10.1 echo

输出语句到控制台上

- echo 命令输出结束后默认会换行，如果不希望换行，可以加上`-n`参数
- echo 不会解析以反斜杠`\`开头的转义字符。比如，`\n`表示换行，echo 默认会将它作为普通字符对待，可以添加-e让转义符生效

#### 10.2 read

read命令的核心是读取，可以读取用户在控制台输入的值，也可以读取文件中的值，这里主要先讲读取控制台输入

基本用法：

```sh
read [-options] [variables] >
```

这里面的'>'符号，可以理解成c++中 cin>> ，意思就是输入，至于options和variables如下表

| 选项options  | 说明variables                                                |
| ------------ | ------------------------------------------------------------ |
| -a array     | 把读取的数据赋值给数组 array，从下标 0 开始。                |
| -d delimiter | 用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。 |
| -e           | 在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。 |
| -n num       | 读取 num 个字符，而不是整行字符，num达到立即读取结束，不用等待用户按下回车键 |
| -p prompt    | 显示提示信息，提示内容为 prompt。                            |
| -r           | 原样读取（Raw mode），不把反斜杠字符解释为转义字符。         |
| -s           | 静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。 |
| -t seconds   | 设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。 |
| -u fd        | 使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。 |

#### 10.3 <span id='exit'>exit</span>

exit 命令可以接受一个范围在0~255的整数值作为参数，代表退出状态。如果不指定，默认状态值是 0，一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。

#### 10.4 declare

定义变量的类型等

```sh
declare [+/-] [aAfFgilprtux] [变量名=变量值]
```

| 选项            | 含义                                                       |
| --------------- | ---------------------------------------------------------- |
| -f [name]       | 列出之前由用户在脚本中定义的函数名称和函数体。             |
| -F [name]       | 仅列出自定义函数名称。                                     |
| -g name         | 在 Shell 函数内部创建全局变量。                            |
| -p [name]       | 显示指定变量的属性和值。                                   |
| -a name         | 声明变量为普通数组。                                       |
| -A name         | 声明变量为关联数组（支持索引下标为字符串）。               |
| -i name         | 将变量定义为整数型。                                       |
| -r name[=value] | 将变量定义为只读（不可修改和删除），等价于 readonly name。 |
| -x name[=value] | 将变量设置为环境变量，等价于 export name[=value]。         |

### 11、运算

shell脚本中不能直接对数据进行运算，因为默认定义的数据都是字符串，除非定义时用declare指定整型可以直接运算，不过一般还是用命令进行计算，这样代码可读性强，不需要翻到上面去看变量是不是整型

常见运算符

| 算术运算符            | 说明/含义                                                |
| --------------------- | -------------------------------------------------------- |
| +、-                  | 加法（或正号）、减法（或负号）                           |
| *、/、%               | 乘法、除法、取余（取模）                                 |
| **                    | 幂运算                                                   |
| ++、--                | 自增和自减，可以放在变量的前面也可以放在变量的后面       |
| !、&&、\|\|           | 逻辑非（取反）、逻辑与（and）、逻辑或（or）              |
| <、<=、>、>=          | 比较符号（小于、小于等于、大于、大于等于）               |
| ==、!=、=             | 比较符号（相等、不相等；对于字符串，= 也可以表示相当于） |
| <<、>>                | 向左移位、向右移位                                       |
| ~、\|、 &、^          | 按位取反、按位或、按位与、按位异或                       |
| =、+=、-=、*=、/=、%= | 赋值运算符，例如 a+=1 相当于 a=a+1，a-=1 相当于 a=a-1    |

常见运算命令

| 运算操作符/运算命令 | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| (( ))               | 用于整数运算，效率很高，**推荐使用**。                       |
| let                 | 用于整数运算，和 (()) 类似。                                 |
| $[]                 | 用于整数运算，不如 (()) 灵活。                               |
| expr                | 可用于整数运算，也可以处理字符串。比较麻烦，需要注意各种细节，不推荐使用。 |
| bc                  | Linux下的一个计算器程序，可以处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器。 |
| declare -i          | 将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。功能有限，仅支持最基本的数学运算（加减乘除和取余），不支持逻辑运算、自增自减等，所以在实际开发中很少使用。不建议使用 |

#### 11.1 (( ))

可以进行整数或逻辑运算

```sh
((表达式))
```

- 使用`$`获取 (( )) 命令的结果
- (( )) 中的变量不需要加上$
- 可以对多个表达式同时进行计算，((a=3+5, b=a+10))，按顺序执行，且变量值会保留，通过$a取
- 如果用$获取多个表达式结果，则只会拿到最后一个表达式的结果，c=$((a=3+5, b=a+10))=18
- 可以进行逻辑运算((a>7))，true为1，false为0

#### 11.2 bc

可以进行小数或逻辑运算，不会，开摆，用到再百度

### 12、逻辑判断

Shell脚本中的判断方法有很多，后续if、while等语句中的condition 就是逻辑表达式，有很多种方法，而且每一种方法有些不同，不能乱用，所以在这里总结一下

#### 12.1 前提：

- 正常的&&和||符号和大部分语言是一致的
- Shell都不支持'>='和'<='的运算，如需使用，请单独写=和>/<然后用或运算符连接

#### **12.2 使用(())进行运算**

- (())的特点是效率高，一般只用在数据判断中，也就是整型或小数的数据，也只能用于整型或小数的判断

#### **12.3 使用[]或test进行运算**

前提：

- []就是test，这两个是一模一样的，区别是在语法规则上有些不同，test写在最前，[]需要将表达式包裹起来

- []和test中间的全部表达式，中间都需要有一个**空格**，这个一定不能少

  ```sh
  [ 1 -eq 2 ]
  test 1 -eq 2
  ```

- []和test比(())优势的地方在于可以比较各种类型的数据甚至文件的信息

比较：

- 整数值比较：[ num1 选项 num2 ]

  - test的数值比较中不允许使用'=','==','>','<'等运算符号

  - | 选 项 | 作 用    |
    | ----- | -------- |
    | -eq   | 等于     |
    | -ne   | 不等于   |
    | -gt   | 大于     |
    | -ge   | 大于等于 |
    | -lt   | 小于     |
    | -le   | 小于等于 |

- 字符比较：[ "string字串1" 选项 "string字串2" ]

  - 字符串一定要用双引号包裹起来

  - | 选 项 | 作 用                                                        |
    | ----- | ------------------------------------------------------------ |
    | ==    | 相等                                                         |
    | =     | 相等                                                         |
    | !=    | 不相等                                                       |
    | -z    | 判空                                                         |
    | -n    | 非空                                                         |
    | \\>   | 判断 str1 是否大于 str2。`\>`是`>`的转义字符，防止`>`被误认为成重定向运算符。 |
    | \\<   | 判断 str1 是否小于 str2。同样，`\<`也是转义字符。            |

  - ==和=的区别：

    当两边字符串都为''的时候，使用==会报错，使用=不会，所以建议直接使用'='

  - 关于判空：

    对于字符串的判空，甚至可以直接使用变量取反进行判断

    ```sh
    [ ! $param ]
    ```

- 文件判断

  - 文件类型判断

    | 选 项       | 作 用                                      |
    | ----------- | ------------------------------------------ |
    | -b filename | 判断文件是否存在，并且是否为块设备文件。   |
    | -c filename | 判断文件是否存在，并且是否为字符设备文件。 |
    | -d filename | 判断文件是否存在，并且是否为目录文件。     |
    | -e filename | 判断文件是否存在。                         |
    | -f filename | 判断文件是否存在，井且是否为普通文件。     |
    | -L filename | 判断文件是否存在，并且是否为符号链接文件。 |
    | -p filename | 判断文件是否存在，并且是否为管道文件。     |
    | -s filename | 判断文件是否存在，并且是否为非空。         |
    | -S filename | 判断该文件是否存在，并且是否为套接字文件。 |

  - 文件权限判断

    | 选 项       | 作 用                                        |
    | ----------- | -------------------------------------------- |
    | -r filename | 判断文件是否存在，并且是否拥有读权限。       |
    | -w filename | 判断文件是否存在，并且是否拥有写权限。       |
    | -x filename | 判断文件是否存在，并且是否拥有执行权限。     |
    | -u filename | 判断文件是否存在，并且是否拥有 SUID 权限。   |
    | -g filename | 判断文件是否存在，并且是否拥有 SGID 权限。   |
    | -k filename | 判断该文件是否存在，并且是否拥有 SBIT 权限。 |

  - 文件比较

    | 选 项                   | 作 用                                                        |
    | ----------------------- | ------------------------------------------------------------ |
    | filename1 -nt filename2 | 判断 filename1 的修改时间是否比 filename2 的新。             |
    | filename -ot filename2  | 判断 filename1 的修改时间是否比 filename2 的旧。             |
    | filename1 -ef filename2 | 判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 |

#### 12.4 使用[[]]进行运算

- []和test的升级版

- 去掉了[]中的`-o`和`-a`选项

- 比较字符串的时候'>'和'<'不需要转义符

- 可以使用正则，使用=~表示后面的是个正则

  ```sh
  [[ str =~ regex ]]
  ```

  

### 13、if语句

**用法：**

```sh
if  condition1
then
   statement1
elif condition2
then
    statement2
……
else
   statementn
fi
```

**解释：**

- condition1 可以用 (())或者[]/test来执行，1为真，0为假

- 可以吧if和then写在同一行，但是这样条件后面必须加上分号

  ```sh
  if  condition;  then
      statement
  fi
  ```

### 14、case in语句

**用法：**

```sh
case expression in
    pattern1)
        statement1
        ;;
    pattern2)
        statement2
        ;;
    pattern3)
        statement3
        ;;
    ……
    *)
        statementn
esac
```

**解释：**

- ;; 相当于break；
- *相当于default
- 支持正则表达式，实际上*)就是正则表达式的一种写法

### 15、while/until循环

**用法：**

```sh
while condition
do
    statements
done
until condition
do
    statements
done
```

死循环直接这样写，用break跳出循环

```sh
while :
do
    break
done
until :
do
    break
done
```

**区别：**

while和until完全相反，就相当于condition取反，一般不用until

### 16、for循环

#### **16.1 常规用法**

```sh
for((exp1; exp2; exp3))
do
    statements
done
```

解释：

- exp1代表初始化条件，可以为空
- exp2代表判断条件，可以为空，为空恒为true
- exp3代表循环一次后运行的代码，可以为空，一般用来自增或者自减

#### 16.2 for in用法

```sh
for variable in value_list
do
    statements
done
```

解释：

- variable代表每一次循环的值
- value_list代表循环的总数据

关于value_list的用法:

- 可以是具体的值，弱数组类型

  ```sh
  for str in 1 2 3 4
  do
      echo $str
  done
  ```

- 可以是一个范围{start..end}，用大括号包裹，并且中间是**两个点**，仅支持数字和字母

  ```sh
  #!/bin/bash
  sum=0
  for n in {1..100}
  do
      ((sum+=n))
  done
  echo $sum
  ```

- 可以是命令的执行结果，用$()得到的结果

  ```sh
  #!/bin/bash
  sum=0
  for n in $(seq 2 2 100)
  do
      ((sum+=n))
  done
  echo $sum
  ```

- 通配符，可以在遍历文件时使用

  ```sh
  #!/bin/bash
  for filename in *.sh
  do
      echo $filename
  done
  ```

- 特殊变量，$#、$*、$@、$?、$$

  ```sh
  for str in $@
  do
  	echo $str
  done
  ```

### 17、select in循环

select它可以显示出带编号的菜单，供用户选择，用户只需要输入对应的编号即可，非常适合终端（Terminal）这样的交互场景

**用法：**

```sh
select variable in value_list
do
    statements
done
```

**例子：**

```sh
#!/bin/bash
echo "chose Num"
select name in "1" "2" "3" "abc" "345"
do
    echo $name
done
echo "You have selected $name"
```

```shell
What is your favourite OS?
1) 1
2) 2
3) 3
4) abc
5) 345
#? 4↙
abc
#?^D
```

**解释：**

- select 是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环，只有遇到 break 语句，或者按下 Ctrl+D 组合键才能结束循环

- `#?`用来提示用户输入菜单编号，用户只需要输入对应的编号即可

- `^D`表示按下 Ctrl+D 组合键，它的作用是结束 select in 循环

- 一般select in是结合case in语句一起使用

  ```shell
  #!/bin/bash
  echo "chosenum"
  select name in "1" "2"
  do
      case $name in
          "1")
              echo "选择了1"
              break
              ;;
          "2")
              echo "选择了2"
              break
              ;;
          *)
              echo "输入错误，请重新输入"
      esac
  done
  ```

### 18、break和continue

用法和其他语法一样，可以跳出循环，唯一不同是shell脚本中可以选择跳出层级

```sh
break n
continue n
```

### 19、函数

**定义**

shell脚本中函数定义的较为随意，并且位置也可以放在任意地方，下面几种写法都可以定义，但是推荐第一种，可读性强

```sh
function name1() {
    statements
    [return value]
}
function name2 {
    statements
    [return value]
}
name3() {
    statements
    [return value]
}
```

**调用与传参**

直接调用，甚至不需要括号，有参数就直接拼在函数名后面，用空格分割

```sh
name param1 param2 param3
```

**接收参数**

shell脚本不像是其他语言在定义的时候就决定好参数个数，而是不需要指定参数个数，完全用特殊变量的形式来接收参数

```sh
function getName(){
    for n in $@
    do
         echo &n
    done
}
```

**函数的返回值**

shell脚本中函数的return不是简单的返回值，而是<a href='#exit'>退出状态</a>，如果我们想要真正获取返回结果，可以通过两种方法

- 全局变量

  ```sh
  #!/bin/bash
  sum=0  #全局变量
  function addsum(){
      sum++
  }
  echo &sum
  ```

- 使用<a href='#replace'>替换</a>的方法获取返回值

  ```sh
  #!/bin/bash
  function addsum(){
      (($1+$2))
      retrun $?
  }
  echo $(addsum 1 2)
  #执行结果为3
  ```

### 20、重定向

大概了解一下：

- 有点类似像java中流的概念，把流重定向到其他地方去
- 目前接触到的大部分需要重定向的操作都是针对文件，这里就完全用文件来说明

- 在 Linux 中，标准输入设备指的是键盘，标准输出设备指的是显示器。

  | 文件描述符 | 文件名 | 类型             | 硬件   |
  | ---------- | ------ | ---------------- | ------ |
  | 0          | stdin  | 标准输入文件     | 键盘   |
  | 1          | stdout | 标准输出文件     | 显示器 |
  | 2          | stderr | 标准错误输出文件 | 显示器 |

#### 20.1 输出

| 类 型                      | 符 号                    | 作 用                                                        |
| -------------------------- | ------------------------ | ------------------------------------------------------------ |
| 标准输出重定向             | command >file            | 以覆盖的方式，把 command 的正确输出结果输出到 file 文件中。  |
|                            | command >>file           | 以追加的方式，把 command 的正确输出结果输出到 file 文件中。  |
| 标准错误输出重定向         | command 2>file           | 以覆盖的方式，把 command 的错误信息输出到 file 文件中。      |
|                            | command 2>>file          | 以追加的方式，把 command 的错误信息输出到 file 文件中。      |
| 正确输出和错误信息同时保存 | command >file 2>&1       | 以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中 |
|                            | command >>file 2>&1      | 以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。 |
|                            | command >file1 2>file2   | 以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。 |
|                            | command >>file1 2>>file2 | 以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。 |
|                            | command >file 2>file     | 不建议这样写                                                 |
|                            | command >>file 2>>file   | 不建议这样写                                                 |
| 丢掉信息                   | command >/dev/null       | 将信息删掉                                                   |

- 完整写法其实应该是fd>file或者fd>>file，fd默认为1，如果为1一般习惯性不写
- fd和>之间不能有空格，fd和file之间无所谓，但是建议都加上，不加上吃外卖没有餐具
- /dev/null像是垃圾桶，但是是个不可恢复数据的垃圾桶

#### 20.2 输入

| 符号                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| command <file          | 将 file 文件中的内容作为 command 的输入。                    |
| command <<END          | 从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。 |
| command \<file1 >file2 | 将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。 |

- <file 就可以简单理解为读取文件
- <<END是让用户在终端输入，可以一直输，知道遇见一样的分解符才能停止，不能使用Ctrl+D退出

## 二、执行shell脚本可能遇到的问题

### 1、windows往Linux上复制文件

可能会报错syntax error near unexpected token `$'\r''，需要输入如下代码

```sh
sed -i 's/\r//g' demo.sh
```

